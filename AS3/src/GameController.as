package {	import flash.display.MovieClip;	import flash.events.*;		import Game.*;	import flash.geom.Rectangle;	import flash.display.BitmapData;	import flash.geom.Point;	import com.freeactionscript.CollisionTest;		import flash.external.ExternalInterface;	import flash.media.Sound;	import flash.media.SoundChannel;	import flash.net.URLRequest;	import flash.media.SoundTransform;	import flash.display.FrameLabel;		public class GameController extends MovieClip {				private var speed:Number;		private var boundaryLimit:Number;		private var idle:Number;				private var pressing_UP:Boolean = false;		private var pressing_DOWN:Boolean = false;		private var pressing_LEFT:Boolean = false;		private var pressing_RIGHT:Boolean = false;				private var blobby:Blobby;		private var blobby_isMoving:Boolean = false;		private var blobby_isIdle:Boolean = false;				private var trail:Array;		private var lastTrailChanged:int = 0;		private var lastTrailInterval:int = 0;				private var boundaryBounds:Rectangle;		private var boundaryData:BitmapData;				private var blobbyBounds:Rectangle;		private var blobbyData:BitmapData;				private var collision:CollisionTest;				private var currentPiece:Object;		private var viewingPiece:Object;		private var currentTitles:Array;		private var hasCurrentPiece:Boolean = false;		private var seen:Array;				private var gameIsOn:Boolean = false;		private var menuIsOn:Boolean = false;		private var soundIsOn:Boolean = false;				private var bgMusic:Sound;		private var bgMusicChannel:SoundChannel;				public function GameController()		{			if(ExternalInterface.available) {				ExternalInterface.addCallback("bl_stopBgMusic", stopBgMusic); 			}		}				public function startBgMusic() {			if(soundIsOn) {				return;			}						if(!bgMusic) {				bgMusic = new Sound(new URLRequest("AS3/media/sound/soundscape.mp3")); 			}						channelBgMusic();			soundIsOn = true;		}				public function stopBgMusic() {			if(!soundIsOn || !bgMusicChannel) {				return;			}						if(bgMusicChannel) {				bgMusicChannel.stop();			}						soundIsOn = false;		}				private function channelBgMusic() {			bgMusicChannel = bgMusic.play(0, 1, new SoundTransform(0.9, -1));			bgMusicChannel.removeEventListener(Event.SOUND_COMPLETE, loopBgMusic);			bgMusicChannel.addEventListener(Event.SOUND_COMPLETE, loopBgMusic);		}				private function loopBgMusic(evt:Event):void		{    		SoundChannel(evt.target).removeEventListener(evt.type, loopBgMusic);    		channelBgMusic();		}				public function initShortcuts()		{			stage.addEventListener(KeyboardEvent.KEY_DOWN, shortcuts);			endGame();			startBgMusic();									if(ExternalInterface.available) {				ExternalInterface.call("bl.setLoaded");				ExternalInterface.addCallback("game_return", this.game_return); 			}		}				public function initBeginButton()		{			if(menuIsOn) {				return;			}						menuIsOn = true;						endGame();			btnPlay.addEventListener(MouseEvent.CLICK, panAndThenGame);						addButton(btnPlay);			//addButton(btn_instructions);			addButton(btn_credits);		}				public function game_return(piece:String) {			startBgMusic();						if(!viewingPiece) {				return;			}						seen.push(viewingPiece.name);						if(viewingPiece.hasOwnProperty('transition')) {				//ExternalInterface.call("console.log", "end transition");				viewingPiece.transition.gotoAndPlay("STOP");			}						viewingPiece = null;		}				public function addButton(btn:MovieClip) {			btn.addEventListener(MouseEvent.MOUSE_OVER, hoverButtonTransition(btn));			btn.addEventListener(MouseEvent.MOUSE_OUT, removeHoverButtonTransition(btn));			btn.buttonMode = true;			btn.useHandCursor = true;		}				public function hoverButtonTransition(btn:MovieClip) {			return function(e:MouseEvent):void {				if(btn !== null) {					btn.gotoAndPlay(2);				}		    };		}				public function removeHoverButtonTransition(btn:MovieClip) {			return function(e:MouseEvent):void {			    if(btn !== null) {					btn.gotoAndPlay(1);				}		    };		}				public function panAndThenGame(evt:MouseEvent = null) {			gotoAndPlay("START_PAN");		}				public function startGame(evt:MouseEvent = null)		{			if(gameIsOn) {				return;			}						gameIsOn = true;			speed = Constants.SPEED;			boundaryLimit = Constants.BOUNDARY_LIMIT;			seen = new Array();						blobby = new Blobby();			idle = 0;						stage.addChild(blobby);						//blobby.cacheAsBitmap = true;			blobby.x = Math.floor(stage.stageWidth / 2);			blobby.y = Math.floor(stage.stageHeight / 2);			blobby.width = 150;			blobby.height = 150;						/*boundaryBounds = boundaryClip.getBounds(stage);			boundaryData = new BitmapData(boundaryBounds.width, boundaryBounds.height, true, 0);			boundaryData.draw(boundaryClip);			blobbyBounds = blobby.getBounds(stage);			blobbyData = new BitmapData(blobbyBounds.width, blobbyBounds.height, true, 0);			blobbyData.draw(blobby);*/						BG_MAP.initTraps();			BG_MAP.initPieces();						//collision = new CollisionTest();						trail = new Array();						stage.addEventListener(Event.ENTER_FRAME, update);			stage.addEventListener(KeyboardEvent.KEY_DOWN, setControlKeys);			stage.addEventListener(KeyboardEvent.KEY_UP, unsetControlKeys);						if(ExternalInterface.available) {				ExternalInterface.call("bl.start");			}		}				public function endGame(evt:MouseEvent = null)		{			if(!gameIsOn) {				return;			}						gameIsOn = false;						stage.removeChild(blobby);					stage.removeEventListener(Event.ENTER_FRAME, update);			stage.removeEventListener(KeyboardEvent.KEY_DOWN, setControlKeys);			stage.removeEventListener(KeyboardEvent.KEY_UP, unsetControlKeys);		}				public function callWebPage(piece:String) {			stopBgMusic();						if(ExternalInterface.available) {				ExternalInterface.call("bl.piece", piece);			}			else {				trace("Played " + piece);				game_return(piece);			}		}				private function shortcuts(evt:KeyboardEvent) {			if(currentLabel != "GAME" && (evt.keyCode == 13 || evt.keyCode == 32)) {				if(currentFrame < 220) {					gotoAndStop("MENU");				}				else if(currentFrame == 220) {					gotoAndPlay("START_PAN");				}				else {					gotoAndStop("GAME");				}			}						// begin transition			if((evt.keyCode == 13 || evt.keyCode == 32) && currentPiece !== null && viewingPiece === null) {				viewingPiece = currentPiece;				if(currentPiece.hasOwnProperty('transition')) {					currentPiece["transition"].addEventListener(Event.ENTER_FRAME, playPieceOnEND);					currentPiece["transition"].gotoAndPlay("ANIM");										//if(currentPiece.hasOwnProperty('position')) {					//	BG_MAP.x = currentPiece.position.x;					//	BG_MAP.y = currentPiece.position.y;					//}				}				else {					playPiece(currentPiece);				}			}		}				private function playPieceOnEND(e:Event) {			if(e.target.currentLabel == 'END') {				currentPiece["transition"].removeEventListener(Event.ENTER_FRAME, playPieceOnEND);				playPiece(currentPiece);			}		}				private function playPiece(piece:Object) {			callWebPage(piece["name"]);		}		private function update(evt:Event) {			movePlayer();		}				private function movePlayer():void {			var animation:String;			var moving:Boolean = (pressing_UP || pressing_DOWN || pressing_LEFT || pressing_RIGHT);			var bgSpeed:int = (speed * 4);						var trailXmove:int = 0;			var trailYmove:int = 0;			var trailYoffset:int = 0;			var trailXoffset:int = 0;						var blobby_x = blobby.x;			var blobby_y = blobby.y;			var MAP_x = BG_MAP.x;			var MAP_y = BG_MAP.y;			//var boundary_x = bg_outline.x;			//var boundary_y = bg_outline.y;						if (pressing_UP)			{				if (blobby.y <= boundaryLimit) 				{					blobby.y += speed;					BG_MAP.y += bgSpeed;					//bg_outline.y += bgSpeed;					trailYmove = bgSpeed;					moving = true;					trailYoffset = -1 * Constants.TRAIL_OFFSET;				}				else {					blobby.y -= speed;					moving = true;					trailYoffset = -1 * Constants.TRAIL_OFFSET;				}			}			if (pressing_DOWN)			{				if (blobby.y >= (stage.stageHeight - boundaryLimit)) 				{					blobby.y -= speed;					BG_MAP.y -= bgSpeed;					//bg_outline.y -= bgSpeed;					trailYmove = -1 * bgSpeed;					moving = true;					trailYoffset = Constants.TRAIL_OFFSET;				}				else {					blobby.y += speed;					moving = true;					trailYoffset = Constants.TRAIL_OFFSET;				}			}			if (pressing_LEFT)			{				if (blobby.x <= boundaryLimit) 				{					blobby.x += speed;					BG_MAP.x += bgSpeed;					//bg_outline.x += bgSpeed;					trailXmove = bgSpeed;										moving = true;					trailXoffset = -1 * Constants.TRAIL_OFFSET;				}				else {					blobby.x -= speed;					moving = true;					trailXoffset = -1 * Constants.TRAIL_OFFSET;				}			}			if (pressing_RIGHT)			{				if (blobby.x >= (stage.stageWidth - boundaryLimit)) 				{					blobby.x -= speed;					BG_MAP.x -= bgSpeed;					//bg_outline.x -= bgSpeed;					trailXmove = -1 * bgSpeed;					moving = true;					trailXoffset = Constants.TRAIL_OFFSET;				}				else {					blobby.x += speed;					moving = true;					trailXoffset = Constants.TRAIL_OFFSET;				}			}						/*if(moving && !collision.complex(bg_outline, blobby)) {				bg_outline.x = boundary_x;				bg_outline.y = boundary_y;				blobby.x = blobby_x;				blobby.y = blobby_y;				BG_MAP.x =  MAP_x;				BG_MAP.y = MAP_y;			}			else */if(moving && !BG_MAP.isWithinBounds(blobby.x, blobby.y)) {				moving = false;				//bg_outline.x = boundary_x;				//bg_outline.y = boundary_y;				blobby.x = blobby_x;				blobby.y = blobby_y;				BG_MAP.x =  MAP_x;				BG_MAP.y = MAP_y;			}			else if(moving && lastTrailInterval >= Constants.TRAIL_EVERY_X_FRAMES) {				drawTrail((blobby_x - trailXoffset), (blobby_y - trailYoffset));				lastTrailInterval = 0;			}			else if(moving) {				lastTrailInterval += 1;				BG_MAP.triggerTraps(blobby_x, blobby_y);			}						if(moving) {				moveTrails(trailXmove, trailYmove);			}						highlightPieces(blobby_x, blobby_y);		}				private function highlightPieces(blobby_x:int, blobby_y:int):void {			currentPiece = BG_MAP.highlightPieces(blobby_x, blobby_y);			var subtitle:String = '';						if(hasCurrentPiece && currentPiece === null) {				blobby.gotoAndPlay("JUMPS");				hasCurrentPiece = false;			}			else if(!hasCurrentPiece && currentPiece) {				blobby.gotoAndPlay("PULSE");				subtitle = "Press space bar for " + currentPiece.name;				hasCurrentPiece = true;				//currentTitles.push(currentPiece["title"]);			}			else if(currentPiece === null) {				hasCurrentPiece = false;			}						if(ExternalInterface.available) {				ExternalInterface.call("bl.subtitle", subtitle);			}		}				private function idlePlayer() {			idle = idle + 1;						if (idle >= Constants.FRAMES_TO_IDLE) {				blobby_isIdle = true;			}					}				private function setControlKeys(evt:KeyboardEvent):void		{			switch (evt.keyCode)			{				case 38:				{					pressing_UP = true;					break;				}				case 40:				{					pressing_DOWN = true;					break;				}				case 37:				{					pressing_LEFT = true;					break;				}				case 39:				{					pressing_RIGHT = true;					break;				}			}		}				private function unsetControlKeys(evt:KeyboardEvent):void		{			switch (evt.keyCode)			{				case 38:				{					pressing_UP = false;					break;				}				case 40:				{					pressing_DOWN = false;					break;				}				case 37:				{					pressing_LEFT = false;					break;				}				case 39:				{					pressing_RIGHT = false;					break;				}			}		}				private function drawTrail(place_x:int, place_y:int):void {			if(!Constants.TRAIL) {				return;			}						if(trail.length >= Constants.TRAIL_MAX) {				trail[lastTrailChanged].x = place_x;				trail[lastTrailChanged].y = place_y;								if(lastTrailChanged >= (Constants.TRAIL_MAX - 1)) {					lastTrailChanged = 0;				}				else {					lastTrailChanged += 1;				}			}			else {				var trailItem:Trail = new Trail();				stage.addChild(trailItem);				trailItem.gotoAndStop(Math.floor(Math.random()*trailItem.totalFrames));				trailItem.x = place_x;				trailItem.y = place_y;				trailItem.width = 20;				trailItem.height = 20;				trail.push(trailItem);			}		}				private function moveTrails(offset_x:int = 0, offset_y:int = 0):void {			if(!Constants.TRAIL) {				return;			}						for (var i:String in trail) 			{ 				trail[i].x += offset_x;				trail[i].y += offset_y;			} 		}				private function inBounds():Boolean {			//var boundary_x = boundary.x;			//var boundary_y = boundary.y;						/*if(pressing_LEFT || pressing_UP) {				boundary_x += Constants.BOUNDARY_LIMIT;				boundary_y += Constants.BOUNDARY_LIMIT;			}						if(pressing_DOWN || pressing_RIGHT) {				boundary_x -= Constants.BOUNDARY_LIMIT;				boundary_y -= Constants.BOUNDARY_LIMIT;			}*/						/*if(blobbyData.hitTest(new Point(blobby.x, blobby.y), 255, boundaryData, new Point(boundary.x, boundary.y), 255))			{				return true;			}			else			{				return false;			}*/						return true;		}	}}